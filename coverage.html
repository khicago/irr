
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>irr: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/khicago/irr/context.go (95.8%)</option>
				
				<option value="file1">github.com/khicago/irr/irc/code.go (0.0%)</option>
				
				<option value="file2">github.com/khicago/irr/irc/dump.go (0.0%)</option>
				
				<option value="file3">github.com/khicago/irr/irr.go (76.5%)</option>
				
				<option value="file4">github.com/khicago/irr/irrbasic.go (60.7%)</option>
				
				<option value="file5">github.com/khicago/irr/metrics.go (92.3%)</option>
				
				<option value="file6">github.com/khicago/irr/result/pkg.go (100.0%)</option>
				
				<option value="file7">github.com/khicago/irr/result/result.go (89.5%)</option>
				
				<option value="file8">github.com/khicago/irr/trace.go (60.0%)</option>
				
				<option value="file9">github.com/khicago/irr/utils.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package irr

import (
        "context"
        "errors"
        "time"
)

// ContextualError 带上下文的错误接口
type ContextualError interface {
        IRR
        Context() context.Context
        WithContext(ctx context.Context) ContextualError
        WithDeadline(deadline time.Time) ContextualError
        WithTimeout(timeout time.Duration) ContextualError
        WithValue(key, val interface{}) ContextualError
}

// ContextualIrr 实现了带上下文的错误
type ContextualIrr struct {
        *BasicIrr
        ctx context.Context
}

// 确保实现接口
var _ ContextualError = (*ContextualIrr)(nil)

// ErrorWithContext 创建带上下文的错误
func ErrorWithContext(ctx context.Context, formatOrMsg string, args ...any) ContextualError <span class="cov8" title="1">{
        recordErrorCreated()
        err := newBasicIrr(formatOrMsg, args...)
        return &amp;ContextualIrr{
                BasicIrr: err,
                ctx:      ctx,
        }
}</span>

// WrapWithContext 包装错误并添加上下文
func WrapWithContext(ctx context.Context, innerErr error, formatOrMsg string, args ...any) ContextualError <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWrapped()
        err := newBasicIrr(formatOrMsg, args...)
        err.inner = innerErr
        return &amp;ContextualIrr{
                BasicIrr: err,
                ctx:      ctx,
        }
}</span>

// TraceWithContext 创建带堆栈跟踪和上下文的错误
func TraceWithContext(ctx context.Context, formatOrMsg string, args ...any) ContextualError <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWithTrace()
        err := newBasicIrr(formatOrMsg, args...)
        err.Trace = createTraceInfo(1, nil)
        return &amp;ContextualIrr{
                BasicIrr: err,
                ctx:      ctx,
        }
}</span>

// TrackWithContext 包装错误并添加堆栈跟踪和上下文
func TrackWithContext(ctx context.Context, innerErr error, formatOrMsg string, args ...any) ContextualError <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWrapped()
        recordErrorWithTrace()
        err := newBasicIrr(formatOrMsg, args...)
        err.inner = innerErr
        err.Trace = createTraceInfo(1, innerErr)
        return &amp;ContextualIrr{
                BasicIrr: err,
                ctx:      ctx,
        }
}</span>

// Context 返回关联的上下文
func (ce *ContextualIrr) Context() context.Context <span class="cov8" title="1">{
        if ce.ctx == nil </span><span class="cov0" title="0">{
                return context.Background()
        }</span>
        <span class="cov8" title="1">return ce.ctx</span>
}

// WithContext 使用新的上下文创建副本
func (ce *ContextualIrr) WithContext(ctx context.Context) ContextualError <span class="cov8" title="1">{
        return &amp;ContextualIrr{
                BasicIrr: ce.BasicIrr,
                ctx:      ctx,
        }
}</span>

// WithDeadline 设置截止时间
func (ce *ContextualIrr) WithDeadline(deadline time.Time) ContextualError <span class="cov8" title="1">{
        ctx, _ := context.WithDeadline(ce.Context(), deadline)
        return ce.WithContext(ctx)
}</span>

// WithTimeout 设置超时时间
func (ce *ContextualIrr) WithTimeout(timeout time.Duration) ContextualError <span class="cov8" title="1">{
        ctx, _ := context.WithTimeout(ce.Context(), timeout)
        return ce.WithContext(ctx)
}</span>

// WithValue 添加键值对
func (ce *ContextualIrr) WithValue(key, val interface{}) ContextualError <span class="cov8" title="1">{
        return ce.WithContext(context.WithValue(ce.Context(), key, val))
}</span>

// ToString 重写以包含上下文信息
func (ce *ContextualIrr) ToString(printTrace bool, split string) string <span class="cov8" title="1">{
        result := ce.BasicIrr.ToString(printTrace, split)

        // 添加上下文信息
        if ce.ctx != nil </span><span class="cov8" title="1">{
                if deadline, ok := ce.ctx.Deadline(); ok </span><span class="cov8" title="1">{
                        result += " [deadline:" + deadline.Format(time.RFC3339) + "]"
                }</span>
                <span class="cov8" title="1">if ce.ctx.Err() != nil </span><span class="cov0" title="0">{
                        result += " [ctx-err:" + ce.ctx.Err().Error() + "]"
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// IsContextError 检查是否为上下文相关错误
func IsContextError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := err.(ContextualError); ok </span><span class="cov8" title="1">{
                return true
        }</span>
        // 递归检查包装的错误
        <span class="cov8" title="1">if unwrapped := errors.Unwrap(err); unwrapped != nil </span><span class="cov8" title="1">{
                return IsContextError(unwrapped)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// ExtractContext 从错误中提取上下文
func ExtractContext(err error) context.Context <span class="cov8" title="1">{
        if ce, ok := err.(ContextualError); ok </span><span class="cov8" title="1">{
                return ce.Context()
        }</span>
        // 递归检查包装的错误
        <span class="cov8" title="1">if unwrapped := errors.Unwrap(err); unwrapped != nil </span><span class="cov8" title="1">{
                return ExtractContext(unwrapped)
        }</span>
        <span class="cov8" title="1">return context.Background()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package irc provides a customized error code system extending the IRR library.
// It defines a `Code` type which represents an error code as an int64,
// and a set of methods that produce rich errors containing both
// formatted messages and these error codes. The package follows the best
// practices of error handling in Go by leveraging the abilities of the IRR library
// to capture stack traces, wrap errors, and provide context while allowing
// for the classification and handling of errors through unified error codes.
//
// Best practices:
//   - Define domain-specific error codes as constants using the `Code` type
//     to maintain a registry of error codes for the application.
//   - Use the `Code`-related methods to create errors with consistent formatting,
//     additional context, and these predefined error codes.
//   - Wrap errors when catching them to maintain the original error context, providing
//     a clear error chain.
//   - Provide stack traces only when it's necessary for debugging, to avoid overpopulating
//     logs with unnecessary details.
//   - Utilize error codes to handle errors gracefully within application logic or
//     when communicating with clients via API responses.
package irc

import (
        "github.com/khicago/irr"
        "strconv"
)

type (
        // Code defines an int64 type for error codes.
        // It extends the error interface by allowing the association of an error message with a code.
        Code int64

        // ICodeGetter is an interface for types that can return an error code.
        ICodeGetter irr.ICodeGetter[int64]

        // ICodeTraverse is an interface for traversing codes in an error chain.
        ICodeTraverse irr.ITraverseCoder[int64]
)

// Verify that Code implements the irr.Spawner interface.
var _ irr.Spawner = Code(0)

// I64 converts a Code to its int64 representation.
func (c Code) I64() int64 <span class="cov0" title="0">{
        return int64(c)
}</span>

// String converts a Code to its string representation, typically for printing.
func (c Code) String() string <span class="cov0" title="0">{
        return strconv.FormatInt(c.I64(), 10)
}</span>

// Error creates an IRR error object with a formatted message and sets the error code.
func (c Code) Error(formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.Error(formatOrMsg, args...).SetCode(c.I64())
}</span>

// Wrap wraps an existing error object with a formatted message and sets the error code.
func (c Code) Wrap(innerErr error, formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.Wrap(innerErr, formatOrMsg, args...).SetCode(c.I64())
}</span>

// TraceSkip creates an IRR error object with stack trace information, skipping the specified
// number of stack frames, and sets the error code.
func (c Code) TraceSkip(skip int, formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.TraceSkip(skip, formatOrMsg, args...).SetCode(c.I64())
}</span>

// Trace creates an IRR error object with stack trace information and sets the error code.
func (c Code) Trace(formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.Trace(formatOrMsg, args...).SetCode(c.I64())
}</span>

// TrackSkip creates an IRR error object that wraps an inner error with stack trace information,
// skipping the specified number of frames, and sets the error code.
func (c Code) TrackSkip(skip int, innerErr error, formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.TrackSkip(skip, innerErr, formatOrMsg, args...).SetCode(c.I64())
}</span>

// Track creates an IRR error object that wraps an inner error with stack trace information and
// sets the error code.
func (c Code) Track(innerErr error, formatOrMsg string, args ...interface{}) irr.IRR <span class="cov0" title="0">{
        return irr.Track(innerErr, formatOrMsg, args...).SetCode(c.I64())
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package irc

import (
        "fmt"
        "strings"
)

func DumpToCodeNError(succ, unknown Code, err error, msgOrFmt string, args ...any) (code Code, msg string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return succ, ""
        }</span>

        <span class="cov0" title="0">sb := strings.Builder{}
        appendMsg := msgOrFmt
        if appendMsg != "" &amp;&amp; len(args) &gt; 0 </span><span class="cov0" title="0">{
                appendMsg = fmt.Sprintf(msgOrFmt, args...)
                sb.WriteString(appendMsg)
                sb.WriteString(", ")
        }</span>

        <span class="cov0" title="0">code = unknown
        errMsg := err.Error()
        if codet, ok := err.(ICodeTraverse); ok </span><span class="cov0" title="0">{
                code = Code(codet.ClosestCode())
                codeStr := codet.GetCodeStr()
                if lenCodeStr := len(codeStr); len(errMsg) &gt; lenCodeStr &amp;&amp; errMsg[:lenCodeStr] == codeStr </span><span class="cov0" title="0">{
                        errMsg = errMsg[lenCodeStr:]
                }</span>
        } else<span class="cov0" title="0"> if codeg, ok := err.(ICodeGetter); ok </span><span class="cov0" title="0">{
                code = Code(codeg.GetCode())
                codeStr := codeg.GetCodeStr()
                if lenCodeStr := len(codeStr); len(errMsg) &gt; lenCodeStr &amp;&amp; errMsg[:lenCodeStr] == codeStr </span><span class="cov0" title="0">{
                        errMsg = errMsg[lenCodeStr:]
                }</span>
        }
        <span class="cov0" title="0">sb.WriteString(errMsg)
        return code, sb.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package irr

// ErrorC creates a new IRR error object with an error code and a formatted message.
// code is an int64 type error code used to identify and classify errors.
// formatOrMsg is a string that accepts printf style format specifiers to generate the error message.
// args are variadic parameters that represent the arguments for the formatting string.
// It returns an IRR error object set with the specific error code.
//
// Usage example:
//
// // Define a sample error code
// const ErrCodeInvalidInput int64 = 1001
//
// // ValidateInput checks the input string and returns an error if it is empty
//
//        func ValidateInput(input string) error {
//            if input == "" {
//                // Create an error object with a specific error code and formatted message using ErrorC
//                return irr.ErrorC(ErrCodeInvalidInput, "validation failed: %s", "input cannot be empty")
//            }
//            // Other input validation logic...
//            return nil
//        }
//
// Note: ErrorC is typically used when you wish to categorize errors or define specific status codes for easier error handling and response later on.
func ErrorC[T int64](code T, formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        recordErrorCreated()
        err := newBasicIrr(formatOrMsg, args...)
        err.SetCode(int64(code))
        return err
}</span>

// Error creates a new IRR error object with a formatted message.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
func Error(formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        recordErrorCreated()
        err := newBasicIrr(formatOrMsg, args...)
        return err
}</span>

// Wrap wraps an existing error object with a given message and an inner error.
// innerErr is the error being wrapped.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
func Wrap(innerErr error, formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWrapped()
        err := newBasicIrr(formatOrMsg, args...)
        err.inner = innerErr
        return err
}</span>

// TraceSkip creates an error object with stack trace and formatted message, skipping a certain number of stack frames.
// skip indicates the number of call frames to skip in the stack trace.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
func TraceSkip(skip int, formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWithTrace()
        err := newBasicIrr(formatOrMsg, args...)
        err.Trace = createTraceInfo(skip+1, nil)
        return err
}</span>

// Trace creates an error object with stack trace and a formatted message.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
// It defaults to skipping one call frame, usually the place where Trace is called.
func Trace(formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        return TraceSkip(1, formatOrMsg, args...)
}</span>

// TrackSkip creates an error object with a stack trace and wraps an inner error, skipping a specified number of stack frames.
// skip indicates the number of call frames to skip in the stack trace.
// innerErr is the error being wrapped.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
func TrackSkip(skip int, innerErr error, formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        recordErrorCreated()
        recordErrorWrapped()
        recordErrorWithTrace()
        err := newBasicIrr(formatOrMsg, args...)
        err.inner = innerErr
        err.Trace = createTraceInfo(skip+1, innerErr)
        return err
}</span>

// Track creates an error object with a stack trace and wraps an inner error.
// innerErr is the error being wrapped.
// formatOrMsg is a string that accepts printf style format specifiers.
// args are variadic parameters that represent the arguments for the formatting string.
// It defaults to skipping one call frame, starting the trace where Track is called.
func Track(innerErr error, formatOrMsg string, args ...any) IRR <span class="cov8" title="1">{
        return TrackSkip(1, innerErr, formatOrMsg, args...)
}</span>

// CatchFailure is used to catch and handle panics within a function, preventing them from causing the program to crash while unifying the encapsulation of non-error information.
// It is declared at the beginning of a function with the defer keyword, ensuring that any panic during function execution can be caught.
// This function takes a callback function as a parameter, which is called when a panic occurs to handle the recovered error.
//
// Usage example:
//
// // A sample function that may cause panic
//
//        func riskyOperation() (err error) {
//            // Defer calling CatchFailure at the start of riskyOperation
//            // to ensure any subsequent panics can be caught and handled
//            defer irr.CatchFailure(func(e error) {
//                // Convert the recovered panic into a regular error so the function can return it
//                // err can be set as a side effect, or the caught e can be handled directly (e.g., logging)
//                // If the panic parameter is nil, e will be nil
//                // If the panic is triggered with an error, the corresponding err will be passed directly
//                // If the panic is another value, ErrUntypedExecutionFailure will be passed in, with the panic value attached to the error message
//                err = e
//            })
//
//            // Trigger an out-of-bounds error that will cause a panic
//            _ = make([]int, 0)[1]
//            // Due to the panic above, the following code will not execute
//            fmt.Println("This line of code will not be executed.")
//
//            // If there is no panic, the function will return a nil error
//            return nil
//        }
//
// // Calling riskyOperation elsewhere, handling errors returned by it
//
//        func main() {
//            if err := riskyOperation(); err != nil {
//                fmt.Printf("Caught error: %v\n", err)
//            } else {
//                fmt.Println("Operation successful, no errors occurred")
//            }
//        }
//
// Note: CatchFailure should only be used to deal with panics caused by unforeseen situations, while regular error handling should be done using the error.
func CatchFailure(set func(err error)) <span class="cov0" title="0">{
        r := recover()

        if r == nil </span><span class="cov0" title="0">{
                set(nil)
                return
        }</span>

        <span class="cov0" title="0">if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                set(e)
                return
        }</span>
        <span class="cov0" title="0">set(Wrap(ErrUntypedExecutionFailure, "panic = %v", r))</span>
}

//func (ir *BasicIrr) Format(s fmt.State, verb rune) {
//        switch verb {
//        case 'q':
//                io.WriteString(s, fmt.Sprintf("%q", ir.Error()))
//        case 's', 'v':
//                io.WriteString(s, ir.Error())
//        }
//}
</pre>
		
		<pre class="file" id="file4" style="display: none">package irr

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
)

type (
        BasicIrr struct {
                inner error

                Code  int64      `json:"code"`
                Msg   string     `json:"msg"`
                Trace *traceInfo `json:"trace"`

                // 使用 map 替代 slice，提升查找性能
                // 使用原子操作的指针，减少锁竞争
                tags atomic.Pointer[map[string][]string] `json:"-"`
                mu   sync.RWMutex                        // 保留锁用于tag操作的原子性
        }
)

func newBasicIrr(formatOrMsg string, args ...any) *BasicIrr <span class="cov8" title="1">{
        err := &amp;BasicIrr{}
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                err.Msg = fmt.Sprintf(formatOrMsg, args...)
        }</span> else<span class="cov8" title="1"> {
                err.Msg = formatOrMsg
        }</span>
        <span class="cov8" title="1">return err</span>
}

var _ IRR = newBasicIrr("")

// Error
// the implementation of error
func (ir *BasicIrr) Error() string <span class="cov8" title="1">{
        return ir.ToString(false, ", ")
}</span>

// Unwrap
// the implementation of IUnwrap
func (ir *BasicIrr) Unwrap() error <span class="cov8" title="1">{
        return ir.inner
}</span>

// Root
// the implementation of ITraverseError
func (ir *BasicIrr) Root() error <span class="cov8" title="1">{
        var err error = ir
        for </span><span class="cov8" title="1">{
                inner := errors.Unwrap(err)
                if inner == nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">err = inner</span>
        }
}

// TraverseToRoot
// the implementation of ITraverseError
func (ir *BasicIrr) TraverseToRoot(fn func(err error) error) (err error) <span class="cov8" title="1">{
        recordTraverseOp()
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        if e, ok := r.(error); ok </span><span class="cov8" title="1">{
                                err = e
                        }</span> else<span class="cov8" title="1"> {
                                err = Wrap(ErrUntypedExecutionFailure, "panic = %v", r)
                        }</span>
                }
        }()
        <span class="cov8" title="1">for inner := error(ir); inner != nil; inner = errors.Unwrap(inner) </span><span class="cov8" title="1">{
                if err = fn(inner); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Source
// the implementation of ITraverseIrr
func (ir *BasicIrr) Source() (err error) <span class="cov8" title="1">{
        _ = ir.TraverseToSource(func(e error, isSource bool) error </span><span class="cov8" title="1">{
                if isSource </span><span class="cov8" title="1">{
                        err = e
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return</span>
}

// TraverseToSource
// the implementation of ITraverseIrr
func (ir *BasicIrr) TraverseToSource(fn func(err error, isSource bool) error) (err error) <span class="cov8" title="1">{
        recordTraverseOp()
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        if e, ok := r.(error); ok </span><span class="cov8" title="1">{
                                err = e
                        }</span> else<span class="cov8" title="1"> {
                                err = Wrap(ErrUntypedExecutionFailure, "panic = %v", r)
                        }</span>
                }
        }()
        <span class="cov8" title="1">for cur := ir; cur != nil; </span><span class="cov8" title="1">{
                isCurSource := cur.inner == nil
                err = fn(cur, isCurSource)
                if isCurSource </span><span class="cov8" title="1">{
                        // 只有在 source 时才返回函数的结果
                        return err
                }</span>
                <span class="cov8" title="1">if next, ok := cur.inner.(*BasicIrr); ok </span><span class="cov8" title="1">{
                        cur = next
                        continue</span>
                }
                // 到达最后一个非 BasicIrr 的错误，这是 source
                <span class="cov8" title="1">err = fn(cur.inner, true)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCodeStr
// Determines how the code is written to the message,
// so that this method can input an empty string to
// avoid outputting the code in the message
func (ir *BasicIrr) GetCodeStr() string <span class="cov0" title="0">{
        if ir.Code == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("code(%d), ", ir.Code)</span>
}

func (ir *BasicIrr) writeSelfTo(sb *strings.Builder, printTrace bool, printCode bool) <span class="cov8" title="1">{
        if printCode </span><span class="cov0" title="0">{
                if codeStr := ir.GetCodeStr(); codeStr != "" </span><span class="cov0" title="0">{
                        sb.WriteString(codeStr)
                }</span>
        }
        <span class="cov8" title="1">sb.WriteString(ir.Msg)

        // 获取tags进行输出
        if tagMap := ir.tags.Load(); tagMap != nil &amp;&amp; len(*tagMap) &gt; 0 </span><span class="cov0" title="0">{
                for key, values := range *tagMap </span><span class="cov0" title="0">{
                        for _, value := range values </span><span class="cov0" title="0">{
                                sb.WriteRune('[')
                                sb.WriteString(key)
                                sb.WriteRune(':')
                                sb.WriteString(value)
                                sb.WriteString("] ")
                        }</span>
                }
        }
        <span class="cov8" title="1">if printTrace &amp;&amp; ir.Trace != nil </span><span class="cov8" title="1">{
                sb.WriteRune(' ')
                ir.Trace.writeTo(sb)
        }</span>
}

// ToString
// consecutive equal codes will be printed only once during the traceback process
func (ir *BasicIrr) ToString(printTrace bool, split string) string <span class="cov8" title="1">{
        sb := strings.Builder{}
        lastCode := int64(0)
        _ = ir.TraverseToSource(func(err error, isSource bool) error </span><span class="cov8" title="1">{
                if irr, ok := err.(*BasicIrr); ok </span><span class="cov8" title="1">{
                        // since have to continue traversing, irr only output itself
                        irr.writeSelfTo(&amp;sb, printTrace, lastCode != irr.Code)
                        lastCode = irr.Code
                }</span> else<span class="cov8" title="1"> {
                        sb.WriteString(err.Error())
                }</span>
                <span class="cov8" title="1">if !isSource </span><span class="cov8" title="1">{
                        sb.WriteString(split)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return sb.String()</span>
}

// LogWarn
// the implementation of ILogCaller
func (ir *BasicIrr) LogWarn(logger IWarnLogger) IRR <span class="cov8" title="1">{
        logger.Warn(ir.ToString(true, "\n"))
        return ir
}</span>

// LogError
// the implementation of ILogCaller
func (ir *BasicIrr) LogError(logger IErrorLogger) IRR <span class="cov8" title="1">{
        logger.Error(ir.ToString(true, "\n"))
        return ir
}</span>

// LogFatal
// the implementation of ILogCaller
func (ir *BasicIrr) LogFatal(logger IFatalLogger) IRR <span class="cov8" title="1">{
        str := ir.ToString(true, "\n")
        logger.Fatal(str)
        // to make sure it has been printed to std output stream
        fmt.Println(str)
        return ir
}</span>

// SetCode
// the implementation of ICoder[int64]
func (ir *BasicIrr) SetCode(val int64) IRR <span class="cov8" title="1">{
        if val != 0 </span><span class="cov8" title="1">{
                recordErrorWithCode(val)
        }</span>
        <span class="cov8" title="1">ir.Code = val
        return ir</span>
}

// GetCode
// the implementation of ICoder[int64]
func (ir *BasicIrr) GetCode() (val int64) <span class="cov0" title="0">{
        return ir.Code
}</span>

// ClosestCode
// the implementation of ITraverseCoder[int64]
func (ir *BasicIrr) ClosestCode() (val int64) <span class="cov0" title="0">{
        eExit := errors.New("stop")
        if err := ir.TraverseCode(func(_ error, code int64) error </span><span class="cov0" title="0">{
                if code != 0 </span><span class="cov0" title="0">{
                        val = code
                        return eExit
                }</span>
                <span class="cov0" title="0">return nil</span>
        }); err != nil &amp;&amp; err != eExit <span class="cov0" title="0">{
                panic("traverse panic")</span>
        }
        <span class="cov0" title="0">return val</span>
}

// TraverseCode
// the implementation of ITraverseCoder[int64]
func (ir *BasicIrr) TraverseCode(fn func(err error, code int64) error) (err error) <span class="cov0" title="0">{
        return ir.TraverseToRoot(func(err error) error </span><span class="cov0" title="0">{
                if t, ok := err.(ICoder[int64]); ok </span><span class="cov0" title="0">{
                        if err = fn(err, t.GetCode()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

// SetTag
// the implementation of ITagger
func (ir *BasicIrr) SetTag(key, val string) <span class="cov0" title="0">{
        ir.mu.Lock()
        defer ir.mu.Unlock()

        // 获取当前的tags map
        currentTags := ir.tags.Load()
        var newTags map[string][]string

        if currentTags == nil </span><span class="cov0" title="0">{
                newTags = make(map[string][]string)
        }</span> else<span class="cov0" title="0"> {
                // 复制现有的tags
                newTags = make(map[string][]string, len(*currentTags))
                for k, v := range *currentTags </span><span class="cov0" title="0">{
                        newTags[k] = make([]string, len(v))
                        copy(newTags[k], v)
                }</span>
        }

        // 添加新的tag
        <span class="cov0" title="0">newTags[key] = append(newTags[key], val)
        ir.tags.Store(&amp;newTags)</span>
}

// GetTag
// the implementation of ITagger
func (ir *BasicIrr) GetTag(key string) (val []string) <span class="cov0" title="0">{
        tagMap := ir.tags.Load()
        if tagMap == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">values := (*tagMap)[key]
        if values == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // 返回副本以避免竞态条件
        <span class="cov0" title="0">result := make([]string, len(values))
        copy(result, values)
        return result</span>
}

func (ir *BasicIrr) GetTraceInfo() *traceInfo <span class="cov8" title="1">{
        return ir.Trace
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package irr

import (
        "sync"
        "sync/atomic"
        "time"
)

// ErrorMetrics 错误统计信息
type ErrorMetrics struct {
        // 错误创建统计
        ErrorCreated   int64 `json:"error_created"`
        ErrorWithCode  int64 `json:"error_with_code"`
        ErrorWithTrace int64 `json:"error_with_trace"`
        ErrorWrapped   int64 `json:"error_wrapped"`

        // 错误遍历统计
        TraverseOps int64 `json:"traverse_ops"`

        // 时间统计
        LastErrorTime time.Time `json:"last_error_time"`

        // 错误码统计
        CodeStats      map[int64]int64 `json:"code_stats"`
        codeStatsMutex sync.RWMutex    `json:"-"`
}

var globalMetrics = &amp;ErrorMetrics{
        CodeStats: make(map[int64]int64),
}

// GetMetrics 获取全局错误统计信息
func GetMetrics() *ErrorMetrics <span class="cov8" title="1">{
        globalMetrics.codeStatsMutex.RLock()
        defer globalMetrics.codeStatsMutex.RUnlock()

        // 返回副本以避免并发问题
        result := &amp;ErrorMetrics{
                ErrorCreated:   atomic.LoadInt64(&amp;globalMetrics.ErrorCreated),
                ErrorWithCode:  atomic.LoadInt64(&amp;globalMetrics.ErrorWithCode),
                ErrorWithTrace: atomic.LoadInt64(&amp;globalMetrics.ErrorWithTrace),
                ErrorWrapped:   atomic.LoadInt64(&amp;globalMetrics.ErrorWrapped),
                TraverseOps:    atomic.LoadInt64(&amp;globalMetrics.TraverseOps),
                LastErrorTime:  globalMetrics.LastErrorTime,
                CodeStats:      make(map[int64]int64, len(globalMetrics.CodeStats)),
        }

        for code, count := range globalMetrics.CodeStats </span><span class="cov8" title="1">{
                result.CodeStats[code] = count
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ResetMetrics 重置统计信息
func ResetMetrics() <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.ErrorCreated, 0)
        atomic.StoreInt64(&amp;globalMetrics.ErrorWithCode, 0)
        atomic.StoreInt64(&amp;globalMetrics.ErrorWithTrace, 0)
        atomic.StoreInt64(&amp;globalMetrics.ErrorWrapped, 0)
        atomic.StoreInt64(&amp;globalMetrics.TraverseOps, 0)

        globalMetrics.codeStatsMutex.Lock()
        globalMetrics.CodeStats = make(map[int64]int64)
        globalMetrics.LastErrorTime = time.Time{}
        globalMetrics.codeStatsMutex.Unlock()
}</span>

// 内部统计函数
func recordErrorCreated() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.ErrorCreated, 1)
        globalMetrics.LastErrorTime = time.Now()
}</span>

func recordErrorWithCode(code int64) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.ErrorWithCode, 1)

        globalMetrics.codeStatsMutex.Lock()
        globalMetrics.CodeStats[code]++
        globalMetrics.codeStatsMutex.Unlock()
}</span>

func recordErrorWithTrace() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.ErrorWithTrace, 1)
}</span>

func recordErrorWrapped() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.ErrorWrapped, 1)
}</span>

func recordTraverseOp() <span class="cov8" title="1">{
        atomic.AddInt64(&amp;globalMetrics.TraverseOps, 1)
}</span>

// ErrorStatsLogger 错误统计日志接口
type ErrorStatsLogger interface {
        LogErrorStats(metrics *ErrorMetrics)
}

// LogStats 记录错误统计信息到日志
func LogStats(logger ErrorStatsLogger) <span class="cov0" title="0">{
        if logger != nil </span><span class="cov0" title="0">{
                logger.LogErrorStats(GetMetrics())
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package result

func OK[T any](result T) Result[T] <span class="cov8" title="1">{
        return Result[T]{
                result: result,
        }
}</span>

func Err[T any](err error) Result[T] <span class="cov8" title="1">{
        return Result[T]{
                err: err,
        }
}</span>

// AndThen - 处理链
// 由于Go 不支持方法形参，因此用包函数的方式提供
// 这个方法将接收一个闭包，如果 Result 是成功的，它会调用闭包，其余上下文直接在闭包内携带，比如 ctx
func AndThen[T any, U any](r Result[T], op func(T) Result[U]) Result[U] <span class="cov8" title="1">{
        if !r.Ok() </span><span class="cov8" title="1">{
                // 如果当前 Result 有错误，直接返回一个带该错误的新 Result
                return Result[U]{err: r.err}
        }</span>
        // 否则，调用 op 传入成功的值，并返回 op 调用的结果
        // r 不适用闭包，而是直接传入，主要是为了清晰的作用域，避免闭包内的 unwrap
        <span class="cov8" title="1">return op(r.result)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package result

import (
        "github.com/khicago/irr"
)

var ErrUnwrapErrOnOK = irr.Error("called UnwrapErr on ok")

type Result[T any] struct {
        result T
        err    error
}

func (r Result[T]) Ok() bool <span class="cov8" title="1">{
        return r.err == nil
}</span>

func (r Result[T]) Err() error <span class="cov8" title="1">{
        return r.err
}</span>

// Match 获取存储在 Result 中的值，如果存在错误，则返回默认值和错误
//
// switch res, err := r.Match() {
// case err != nil: error handling branch
// default: ...
// }
func (r Result[T]) Match() (T, error) <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov8" title="1">{
                var zero T
                return zero, r.err
        }</span>
        <span class="cov8" title="1">return r.result, nil</span>
}

// Unwrap 强制解包 Result.result，如果 Result 包含错误，则抛出 panic
// Result 不会被消耗，todo 这个可以考虑考虑
func (r Result[T]) Unwrap() T <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov0" title="0">{
                panic(r.Err)</span>
        }
        <span class="cov8" title="1">return r.result</span>
}

// UnwrapOr 强制解包 Result，如果 Result 不包含错误，则抛出默认值
// Result 不会被消耗，todo 这个可以考虑考虑
func (r Result[T]) UnwrapOr(defaultVal T) T <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov8" title="1">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return r.result</span>
}

// UnwrapErr 强制解包 Result.Err，如果 Result 不包含错误，则抛出 panic
// Result 不会被消耗，todo 这个可以考虑考虑
func (r Result[T]) UnwrapErr() error <span class="cov8" title="1">{
        if r.err == nil </span><span class="cov8" title="1">{
                panic(irr.Wrap(ErrUnwrapErrOnOK, "value= %v", r.result))</span>
        }
        <span class="cov8" title="1">return r.err</span>
}

// Expect 返回 Result 中的值或者在发生错误时显示指定的消息
// Result 不会被消耗，todo 这个可以考虑考虑
func (r Result[T]) Expect(formatOrMsg string, params ...any) T <span class="cov8" title="1">{
        if r.err != nil </span><span class="cov8" title="1">{
                e := irr.Wrap(r.Err(), formatOrMsg, params...)
                panic(e)</span>
        }
        <span class="cov8" title="1">return r.result</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package irr

import (
        "path"
        "runtime"
        "strconv"
        "strings"
        "sync"
)

type (
        traceInfo struct {
                FuncName string `json:"func"`
                FileName string `json:"file"`
                Line     int    `json:"line"`

                // 缓存字符串表示，避免重复构建
                cached string
                once   sync.Once
        }
)

func (t *traceInfo) String() string <span class="cov0" title="0">{
        t.once.Do(func() </span><span class="cov0" title="0">{
                var sb strings.Builder
                sb.Grow(len(t.FuncName) + len(t.FileName) + 16) // 预分配容量
                t.writeTo(&amp;sb)
                t.cached = sb.String()
        }</span>)
        <span class="cov0" title="0">return t.cached</span>
}

// writeTo a string builder
// faster than fmt.Sprintf("%s %s:%d", t.FuncName, t.FileName, t.Line)
// benchmark 88ms vs 213ms
func (t *traceInfo) writeTo(sb *strings.Builder) *strings.Builder <span class="cov8" title="1">{
        sb.WriteString(t.FuncName)
        sb.WriteRune('@')
        sb.WriteString(t.FileName)
        sb.WriteRune(':')
        sb.WriteString(strconv.Itoa(t.Line))
        return sb
}</span>

var (
        // 堆栈信息缓存池，复用 traceInfo 对象
        tracePool = sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        return &amp;traceInfo{}
                }</span>,
        }
)

func generateStackTrace(skipMore int) *traceInfo <span class="cov8" title="1">{
        pc, _, _, _ := runtime.Caller(1 + skipMore)
        caller := runtime.FuncForPC(pc)
        funcName := caller.Name()
        fileName, line := caller.FileLine(pc)

        // 从池中获取对象，减少内存分配
        trace := tracePool.Get().(*traceInfo)
        trace.FuncName = path.Base(funcName)
        trace.FileName = fileName
        trace.Line = line
        trace.cached = ""        // 重置缓存
        trace.once = sync.Once{} // 重置once

        return trace
}</span>

// 优化：添加释放方法，虽然在错误处理中不常用，但提供了可能性
func (t *traceInfo) Release() <span class="cov0" title="0">{
        t.FuncName = ""
        t.FileName = ""
        t.Line = 0
        t.cached = ""
        t.once = sync.Once{}
        tracePool.Put(t)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package irr

// createTraceInfo will skip some stack layer corresponding to the method it self
// Thus when implement a func `A` which called createTraceInfo, the stack head will
// be `A` when skip= 1 are set, and this is the most general situation.
// There are another cases that use skip &gt; 1, for example, when implement some
// basic lib, you may need the stack starts at a frontier caller.
func createTraceInfo(skip int, innerErr error) *traceInfo <span class="cov8" title="1">{
        t := generateStackTrace(1 + skip)
        if innerErr == nil </span><span class="cov8" title="1">{
                return t
        }</span>
        <span class="cov8" title="1">if irr, ok := innerErr.(IRR); !ok || irr.GetTraceInfo() == nil || *(irr.GetTraceInfo()) != *t </span><span class="cov8" title="1">{
                return t
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
